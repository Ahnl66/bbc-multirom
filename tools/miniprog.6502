\ MiniProg: A barebones programmer tool for MultiROM flash cartridge.

\ Compatible with both Master and Electron (modifies itself at runtime to use
\ appropriate ROMSEL address). Suitable for MODE 6 and PAGE <= &1D00. Loads
\ entire ROM image into buffer at once with OSFILE &FF, should be able to load
\ from tape without motor control.

\ In theory, should be able to program any SST39SF010 sideways ROM hardware, so
\ long as it maps A0-A13 directly, and A14 to the low bit of ROMSEL.

\ If set, bundle a ROM image to create a 'self-contained' installer
ROM_IMAGE =? ""

\ 'Friendly' name for bundled ROM image, shown at startup. Defaults to ROM image filename.
ROM_IMAGE_NAME =? ""

\ MOS routines
osasci = &FFE3
osbyte = &FFF4
osfile = &FFDD
osword = &FFF1

\ System locations
romzp = &F4         \ RAM copy of ROMSEL register
romsel = &FE30      \ Sideways ROM paging register (for Master)
elk_romsel = &FE05  \ Sideways ROM paging register (for Electron)

strbuf = &0600  \ BASIC won't mind if we borrow its string buffer

\ Variables
romsav = &70    \ Previous ROM number to restore
romptr = &72    \ Pointer into ROM
bufptr = &74    \ Pointer into RAM buffer

ORG &1D00
.begin
\ Check that we have enough free memory for the buffer
\ We need up to &5FFF
    LDA #&84:JSR osbyte     \ OSBYTE &84 - read start of screen memory into XY
    CPY #&60:BCS ram_ok     \ Check high byte to make sure screen memory starts at >=&6000
    BRK
    EQUS 0, "No room. Use MODE 6.", 0
.ram_ok
    LDA #&EA:LDX #0:LDY #$FF:JSR osbyte
    TXA:BEQ tube_ok
    BRK
    EQUS 0, "Can't run on Tube.", 0
.exit
    RTS     \ Just a convenient place to put this, we branch to it in checks below
.tube_ok

    LDA #&00:LDX #&01:JSR osbyte    \ OSBYTE &00,&01: return host type in X
    CPX #0:BNE not_elk              \ Are we running on an Electron?
    LDA #LO(elk_romsel):STA romsel_sta+1 \ Yes, patch ourself to use &FE05 for ROMSEL
.not_elk

    LDX #(str_header - strings)
    JSR print_string

\ Prompt for filename and load into buffer
IF ROM_IMAGE = ""
    LDX #(str_file_prompt - strings)
    JSR print_string

    LDA #0
    LDX #LO(ctl_filename_prompt):LDY #HI(ctl_filename_prompt)
    JSR osword      \ OSWORD &00 - read line from console
    BCS exit        \ Escape pressed? get outta here

    LDA strbuf
    CMP #&0D
    BNE load_file   \ Got filename, try to load it

\ Filename was blank, erase ROM only
    LDA #0:PHA      \ push zeroed 'program enable' flag onto stack
    BEQ rom_prompt  \ always taken

.load_file
    LDA #&FF:PHA    \ push nonzero 'program enable' flag onto stack
    LDX #LO(ctl_file_load):LDY #HI(ctl_file_load)
    JSR osfile      \ OSFILE &FF - load whole file into memory
ELSE
    LDA #&FF:PHA    \ Always set program-enable flag with bundled ROM
ENDIF

\ Prompt for ROM number to program
.rom_prompt
    LDX #(str_rom_prompt - strings)
    JSR print_string

\ We use the OSWORD 0 control block to restrict input to a single character
\ between '0' and '3'
    LDA #0
    LDX #LO(ctl_rom_prompt):LDY #HI(ctl_rom_prompt)
    JSR osword      \ OSWORD &00 - read line from console
    BCS exit        \ Escape pressed? get outta here

    LDA strbuf:CMP #&0D:BEQ rom_prompt  \ Blank line? try again

\ Convert a single hex digit
\ Constraints (set in control block):
\   - only 1 character
\   - >= '0'
\   - <= 'f'
    SEC:SBC #'0'
    CMP #&0A:BCC convert_done   \ got 0 - 9
    SBC #'A'-'0'-&0A
    CMP #&0A:BMI rom_prompt     \ exclude chars < A
    CMP #&10:BCC convert_done   \ got A - F
    SBC #'a'-'A'
    CMP #&0A:BMI rom_prompt     \ exclude chars < a
.convert_done                   \ got a - f
    PHA

{
\ Check for valid flash chip
    TAX:JSR read_id
    CMP #&BF:BNE not_flash               \ Mfg ID &BF = SST
    CPY #&B5:BNE unknown:BEQ is_flash    \ Product ID &B5 = SST39SF010
.not_flash
\ read_id returns an invalid manufacturer ID of &00 if ID cannot be read
    CMP #0
    BNE unknown     \ Unknown nonzero manufacturer ID. Bail out!
    CPY #0
    BNE ram         \ &00,&01 - writeable memory, probably sideways RAM
    BRK             \ &00,&00 - no ID, not writeable, probably real ROM
    EQUS 0, "Can't program ROM.", 0
.ram
    BRK
    EQUS 0, "Can't program SWRAM.", 0
.unknown
    BRK
    EQUS 0, "Unknown chip.", 0
.is_flash
}

\ Erase selected ROM in preparation for programming
    PLA:TAX
    JSR erase_rom

    PLA:BEQ finished    \ pull 'program enable' flag off stack, skip programming if clear

\ Program contents of buffer into selected ROM
    LDA #LO(buffer):STA bufptr
    LDA #HI(buffer):STA bufptr+1

    LDA #&00:STA romptr
    LDA #&80:STA romptr+1
    LDY #0
{
.loop
    LDA (bufptr),Y
    JSR write_byte
    INY
    BNE loop
    INC romptr+1:INC bufptr+1
    LDA romptr+1:CMP #&C0:BNE loop
}

\ Verify programmed ROM against buffer
    LDA #LO(buffer):STA bufptr
    LDA #HI(buffer):STA bufptr+1

    LDA #&00:STA romptr
    LDA #&80:STA romptr+1
    LDY #0
{
.loop
    JSR read_byte
    CMP (bufptr), Y
    BEQ ok
    BRK
    EQUS 0, "Verify failed.", 0
.ok
    INY
    BNE loop
    INC romptr+1:INC bufptr+1
    LDA romptr+1:CMP #&C0:BNE loop
}

.finished
    LDX #(str_done - strings)
\ Fall through to print 'Done' string and then exit

\ Print a null-terminated string
\ Arguments:    X - offset of string to print from 'strings' label
\ Destroys:     A, X
\ Preserves:    Y
.print_string
{
    LDA strings, X
    BEQ done
    JSR osasci
    INX
    JMP print_string
.done
    RTS
}

INCLUDE "flashio.6502"

.strings
.str_header
    EQUS "MultiROM flash cartridge mini-programmer", &0D

    IF ROM_IMAGE <> ""
        EQUS "Preloaded with "
        IF ROM_IMAGE_NAME <> ""
            EQUS ROM_IMAGE_NAME
        ELSE
            EQUS ROM_IMAGE
        ENDIF
        EQUB &0D
    ENDIF

    EQUB 0
IF ROM_IMAGE = ""
.str_file_prompt
    EQUS "ROM Filename (blank to erase)? ", 0
ENDIF
.str_rom_prompt
    EQUS "Slot # (0-F)? ", 0
.str_done
    EQUS "Done.", &0D, 0

.ctl_rom_prompt
    EQUW strbuf \ Read string to strbuf
    EQUB 1      \ Maximum length 1 char
    EQUB '0'    \ Reject characters < '0'
    EQUB 'f'    \ Reject characters > 'f'

IF ROM_IMAGE <> ""
.buffer
    INCBIN ROM_IMAGE
    GUARD &6000
ELSE
.ctl_filename_prompt
    EQUW strbuf \ Read string to strbuf
    EQUB 255    \ Max length 255 chars
    EQUB &20    \ Accept any printable character
    EQUB &7E
.ctl_file_load
    EQUW strbuf \ Get filename from strbuf
    EQUW buffer \ Load file to buffer
    EQUW &0000
    EQUW &0000
    EQUW &0000
    EQUW &0000
.buffer
    GUARD &2000
ENDIF

.end

SAVE begin, end, begin
